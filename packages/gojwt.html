<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Go JWT (golang-jwt/jwt/v5) — Practical Guide</title>

<style>
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  background: #0d0d0f;
  color: #f5f5f7;
  padding: 60px 30px;
  line-height: 1.7;
}

.container {
  max-width: 920px;
  margin: auto;
}

.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 26px;
  gap: 12px;
}

h1 { font-weight: 650; margin: 0; }
h2 { margin-top: 46px; font-weight: 560; }
h3 { margin-top: 26px; font-weight: 560; }

a { color: #999; text-decoration: none; }
a:hover { color: #ff453a; }

hr {
  border: 0;
  border-top: 1px solid rgba(255,255,255,0.12);
  margin: 34px 0;
}

.badge {
  display: inline-block;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.9rem;
  color: #999;
  margin-right: 8px;
}

.code-box {
  font-family: Menlo, monospace;
  background: #0b1a14;
  padding: 18px;
  border-radius: 12px;
  margin: 16px 0;
  white-space: pre;
  overflow-x: auto;
  font-size: 0.95rem;
  border: 1px solid rgba(255,255,255,0.12);
}

.inline-code {
  font-family: Menlo, monospace;
  font-size: 0.95em;
  padding: 2px 6px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
}

.keyword { color: #ff453a; }
.type { color: #4da3ff; }
.string { color: #30d158; }
.number { color: #bf5af2; }
.muted { color: #999; }

.grid2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin-top: 14px;
}
@media (max-width: 860px) {
  .grid2 { grid-template-columns: 1fr; }
}

.card {
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 14px;
  padding: 16px 16px;
  background: rgba(255,255,255,0.04);
}

ul { padding-left: 18px; }
li { margin: 6px 0; }

table {
  width: 100%;
  border-collapse: collapse;
  margin: 14px 0;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 12px;
  overflow: hidden;
}
td, th {
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.12);
  vertical-align: top;
}
th { text-align: left; color: #999; font-weight: 600; }
tr:last-child td { border-bottom: 0; }

.callout {
  border-left: 4px solid #ff453a;
  padding: 12px 14px;
  background: rgba(255,69,58,0.08);
  border-radius: 12px;
  margin: 14px 0;
}

.footer {
  text-align: center;
  margin-top: 52px;
  color: #999;
}
</style>

</head>

<body>
<div class="container">

  <div class="topbar">
    <div>
      <h1>JWT in Go — Practical Guide</h1>
      <div class="muted" style="margin-top:6px;">
        <span class="badge">package: github.com/golang-jwt/jwt/v5</span>
        <span class="badge">HS256</span>
        <span class="badge">production basics</span>
      </div>
    </div>
  </div>

  <p class="muted">
    This page explains JWT the way you actually use it in Go APIs: create token on login, send token to client, verify token on protected routes.
    No extra theory you won’t use.
  </p>

  <hr>

  <h2>1) What a JWT is</h2>
  <p>
    A JWT is a <span class="inline-code">string</span> made of 3 parts:
  </p>

  <div class="code-box">HEADER.PAYLOAD.SIGNATURE</div>

  <div class="grid2">
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Header</h3>
      <p class="muted" style="margin:0;">
        Auto-generated metadata (algorithm + type).
      </p>
      <div class="code-box">{"alg":"HS256","typ":"JWT"}</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0;">Payload</h3>
      <p class="muted" style="margin:0;">
        Your data (called <span class="inline-code">claims</span>) — like user_id, role, exp.
      </p>
      <div class="code-box">{"user_id":123,"role":"admin","exp":1772018872}</div>
    </div>
  </div>

  <div class="card" style="margin-top:14px;">
    <h3 style="margin:0 0 8px 0;">Signature (IMPORTANT)</h3>
    <p style="margin:0;">
      Signature is <span class="keyword">not encryption</span>. It does not hide the payload. It only proves the token wasn’t modified.
    </p>
    <div class="code-box">signature = HMAC(secret, base64(header) + "." + base64(payload))</div>
    <p class="muted" style="margin:0;">
      Anyone can base64-decode header/payload. But without the secret, they cannot create a valid signature.
    </p>
  </div>

  <div class="callout">
    JWT is a signed identity card. It prevents tampering. It does not hide what’s inside.
  </div>

  <hr>

  <h2>2) What JWT is used for</h2>
  <ul>
    <li><span class="keyword">Login once</span>, then send token on every request.</li>
    <li>Protect routes (only allow requests with valid token).</li>
    <li>Identify user (<span class="inline-code">user_id</span>) without storing server sessions.</li>
  </ul>

  <h3>Typical flow</h3>
  <div class="code-box">POST /login  -> server returns token
GET /profile -> client sends Authorization: Bearer &lt;token&gt;
server verifies -> extracts user_id -> continues</div>

  <hr>

  <h2>3) The only JWT package pieces you’ll keep using</h2>

  <table>
    <thead>
      <tr>
        <th>Thing</th>
        <th>What it is</th>
        <th>When you use it</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="inline-code">jwt.MapClaims</span></td>
        <td>Payload map (<span class="inline-code">map[string]any</span>)</td>
        <td>Quick claims: user_id, role, exp</td>
      </tr>
      <tr>
        <td><span class="inline-code">jwt.NewWithClaims</span></td>
        <td>Creates token object in memory</td>
        <td>Before signing</td>
      </tr>
      <tr>
        <td><span class="inline-code">token.SignedString(secret)</span></td>
        <td>Signs & returns the token string</td>
        <td>Return token after login</td>
      </tr>
      <tr>
        <td><span class="inline-code">jwt.Parse</span></td>
        <td>Verify signature + decode</td>
        <td>When client sends token back</td>
      </tr>
      <tr>
        <td><span class="inline-code">token.Valid</span></td>
        <td>Boolean validity</td>
        <td>Gate protected endpoints</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <h2>4) Minimal “create token” code</h2>
  <div class="code-box">package main

import (
  "time"
  "github.com/golang-jwt/jwt/v5"
)

func CreateToken(secret []byte, userID int64, role string) (string, error) {
  claims := jwt.MapClaims{
    "user_id": userID,
    "role":    role,
    "exp":     time.Now().Add(24 * time.Hour).Unix(),
  }

  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
  return token.SignedString(secret)
}</div>

  <p class="muted">
    <span class="inline-code">exp</span> is Unix seconds. When current time &gt; exp, parsing fails as “expired”.
  </p>

  <hr>

  <h2>5) Minimal “verify token + read claims” code</h2>
  <div class="code-box">package main

import (
  "errors"
  "github.com/golang-jwt/jwt/v5"
)

func VerifyToken(secret []byte, tokenString string) (jwt.MapClaims, error) {

  parsed, err := jwt.Parse(tokenString, func(t *jwt.Token) (any, error) {
    if t.Method != jwt.SigningMethodHS256 {
      return nil, errors.New("unexpected signing method")
    }
    return secret, nil
  })

  if err != nil {
    return nil, err
  }
  if !parsed.Valid {
    return nil, errors.New("invalid token")
  }

  claims, ok := parsed.Claims.(jwt.MapClaims)
  if !ok {
    return nil, errors.New("bad claims type")
  }

  return claims, nil
}</div>

  <div class="callout">
    Production tip: always check algorithm (<span class="inline-code">t.Method</span>) before returning the secret.
  </div>

  <hr>

  <h2>6) Extracting values from MapClaims</h2>
  <p>
    MapClaims values are <span class="inline-code">any</span>. After JSON decoding, numbers often become <span class="inline-code">float64</span>.
  </p>

  <div class="code-box">claims, _ := VerifyToken(secret, tokenString)

userID := int64(claims["user_id"].(float64))
role := claims["role"].(string)
exp  := int64(claims["exp"].(float64))</div>

  <div class="callout">
    If you want to avoid <span class="inline-code">float64</span> and type assertions, use a struct claims type (below).
  </div>

  <hr>

  <h2>7) “Production-clean” claims with a struct (recommended)</h2>
  <p>
    This keeps things typed and avoids guessing claim types.
  </p>

  <div class="code-box">package main

import (
  "errors"
  "time"
  "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
  UserID int64  `json:"user_id"`
  Role   string `json:"role"`
  jwt.RegisteredClaims
}

func CreateToken2(secret []byte, userID int64, role string) (string, error) {
  c := Claims{
    UserID: userID,
    Role: role,
    RegisteredClaims: jwt.RegisteredClaims{
      ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
      IssuedAt:  jwt.NewNumericDate(time.Now()),
    },
  }

  token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)
  return token.SignedString(secret)
}

func VerifyToken2(secret []byte, tokenString string) (*Claims, error) {
  c := &Claims{}

  parsed, err := jwt.ParseWithClaims(tokenString, c, func(t *jwt.Token) (any, error) {
    if t.Method != jwt.SigningMethodHS256 {
      return nil, errors.New("unexpected signing method")
    }
    return secret, nil
  })
  if err != nil {
    return nil, err
  }
  if !parsed.Valid {
    return nil, errors.New("invalid token")
  }
  return c, nil
}</div>

  <hr>

  <h2>8) Minimal HTTP “middleware” pattern</h2>
  <p>
    This is the real-world pattern: get token from header, verify, then continue.
  </p>

  <div class="code-box">package main

import (
  "net/http"
  "strings"
)

func RequireAuth(secret []byte, next http.HandlerFunc) http.HandlerFunc {
  return func(res http.ResponseWriter, req *http.Request) {

    authHeader := req.Header.Get("Authorization")
    if authHeader == "" {
      http.Error(res, "missing token", http.StatusUnauthorized)
      return
    }

    parts := strings.SplitN(authHeader, " ", 2)
    if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
      http.Error(res, "bad auth header", http.StatusUnauthorized)
      return
    }

    tokenString := parts[1]

    claims, err := VerifyToken2(secret, tokenString)
    if err != nil {
      http.Error(res, "invalid token", http.StatusUnauthorized)
      return
    }

    _ = claims
    next(res, req)
  }
}</div>

  <hr>

  <h2>9) Production basics you must do</h2>

  <div class="grid2">
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Must-have</h3>
      <ul style="margin:0;">
        <li>Always set <span class="inline-code">exp</span> (token expiry)</li>
        <li>Keep secret in env var (not hardcoded)</li>
        <li>Check signing method before verifying</li>
        <li>Use HTTPS in real deployments</li>
      </ul>
    </div>
    <div class="card">
      <h3 style="margin:0 0 8px 0;">Common mistakes</h3>
      <ul style="margin:0;">
        <li>Putting sensitive data in payload</li>
        <li>No expiration (stolen token works forever)</li>
        <li>Not validating algorithm</li>
        <li>Very long token lifetimes</li>
      </ul>
    </div>
  </div>

  <div class="callout">
    Store only identifiers in JWT (like user_id + role). Don’t store secrets.
  </div>

  <hr>

  <h2>10) Quick glossary</h2>
  <table>
    <tbody>
      <tr>
        <th>Claim</th>
        <td>A key/value inside payload (example: user_id, exp)</td>
      </tr>
      <tr>
        <th>HS256</th>
        <td>HMAC SHA256 signing (same secret used to sign and verify)</td>
      </tr>
      <tr>
        <th>Bearer token</th>
        <td>Token sent in header: <span class="inline-code">Authorization: Bearer &lt;token&gt;</span></td>
      </tr>
      <tr>
        <th>Stateless</th>
        <td>Server doesn’t store session; token carries identity data</td>
      </tr>
    </tbody>
  </table>

  <div class="footer">
    © Rakshith
  </div>

</div>
</body>
</html>